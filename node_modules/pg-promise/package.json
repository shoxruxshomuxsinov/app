{
  "name": "pg-promise",
  "version": "7.0.3",
  "description": "Promises interface for PostgreSQL",
  "main": "lib/index.js",
  "typings": "typescript/pg-promise.d.ts",
  "scripts": {
    "test": "jasmine-node test",
    "test-native": "jasmine-node test --config PG_NATIVE true",
    "doc": "./node_modules/.bin/jsdoc -c ./jsdoc/jsdoc.js ./jsdoc/README.md -t ./jsdoc/templates/custom",
    "coverage": "istanbul cover ./node_modules/jasmine-node/bin/jasmine-node test",
    "travis": "npm run lint && istanbul cover ./node_modules/jasmine-node/bin/jasmine-node test --captureExceptions && cat ./coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js && rm -rf ./coverage",
    "lint": "./node_modules/.bin/eslint ./lib ./test/*.js ./test/db"
  },
  "files": [
    "lib",
    "typescript"
  ],
  "homepage": "https://github.com/vitaly-t/pg-promise",
  "repository": {
    "type": "git",
    "url": "https://github.com/vitaly-t/pg-promise.git"
  },
  "bugs": {
    "url": "https://github.com/vitaly-t/pg-promise/issues",
    "email": "vitaly.tomilov@gmail.com"
  },
  "keywords": [
    "pg",
    "promise",
    "postgres"
  ],
  "author": {
    "name": "Vitaly Tomilov",
    "email": "vitaly.tomilov@gmail.com"
  },
  "license": "MIT",
  "engines": {
    "node": ">=4.5",
    "npm": ">=2.15"
  },
  "dependencies": {
    "manakin": "~0.5.1",
    "pg": "~7.3.0",
    "pg-minify": "~0.5.3",
    "spex": "~2.0.0"
  },
  "devDependencies": {
    "@types/node": "~8.0.46",
    "JSONStream": "~1.3.1",
    "bluebird": "~3.5.1",
    "coveralls": "~3.0.0",
    "eslint": "~4.9.0",
    "istanbul": "~0.4.5",
    "jasmine-node": "~1.14.5",
    "jsdoc": "~3.5.5",
    "pg-query-stream": "~1.1.1",
    "typescript": "~2.5.3"
  },
  "readme": "pg-promise\r\n===========\r\n\r\n[Promises/A+] interface for PostgreSQL.\r\n\r\n[![Build Status](https://travis-ci.org/vitaly-t/pg-promise.svg?branch=master)](https://travis-ci.org/vitaly-t/pg-promise)\r\n[![Coverage Status](https://coveralls.io/repos/vitaly-t/pg-promise/badge.svg?branch=master)](https://coveralls.io/r/vitaly-t/pg-promise?branch=master)\r\n[![Package Quality](http://npm.packagequality.com/shield/pg-promise.svg)](http://packagequality.com/#?package=pg-promise)\r\n[![Join the chat at https://gitter.im/vitaly-t/pg-promise](https://img.shields.io/gitter/room/vitaly-t/pg-promise.svg)](https://gitter.im/vitaly-t/pg-promise?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\n---\r\n\r\n<a href='https://pledgie.com/campaigns/32367'><img alt='Click here to lend your support to: pg-promise and make a donation at pledgie.com !' src='https://pledgie.com/campaigns/32367.png?skin_name=chrome' border='0' ></a> <a href='https://www.paypal.me/VitalyTomilov'><img alt='Click here to lend your support to: pg-promise and make a donation at PayPal.com !' src='https://github.com/vitaly-t/pg-promise/raw/master/jsdoc/paypal.png' border='0' ></a>\r\n\r\n* [About](#about)\r\n* [Documentation](#documentation)  \r\n* [Contributing](#contributing)    \r\n* [Usage]\r\n  - [Methods](#methods)\r\n  - [Query Formatting](#query-formatting)\r\n    - [Index Variables]  \r\n    - [Named Parameters]\r\n  - [Formatting Filters](#formatting-filters)          \r\n    - [SQL Names]  \r\n    - [Raw Text]  \r\n    - [Open Values]\r\n    - [JSON Filter]\r\n    - [CSV Filter]    \r\n  - [Custom Type Formatting]            \r\n  - [Query Files](#query-files)    \r\n  - [Tasks](#tasks)    \r\n  - [Transactions](#transactions)\r\n    - [Nested Transactions](#nested-transactions)   \r\n    - [Configurable Transactions](#configurable-transactions)\r\n  - [ES6 Generators](#es6-generators)\r\n  - [Library de-initialization](#library-de-initialization)\r\n* [History](#history)\r\n* [License](#license)\r\n\r\n---\r\n\r\n# About\r\n\r\nBuilt on top of [node-postgres], this library adds the following:\r\n\r\n* Automatic connections\r\n* Automatic transactions\r\n* Powerful query-formatting engine\r\n* Support for ES6 generators and ES7 `async/await`\r\n* Declarative approach to handling query results\r\n* Global events reporting for central handling\r\n* Extensive support for external SQL files\r\n* Support for all promise libraries\r\n\r\n# Documentation\r\n\r\nChapter [Usage] below explains the basics you need to know, while the [Official Documentation]\r\ngets you started, and provides links to all other resources.\r\n\r\n# Contributing\r\n\r\nPlease read the [Contribution Notes](https://github.com/vitaly-t/pg-promise/blob/master/CONTRIBUTING.md) before opening any new issue or PR.\r\n\r\n# Usage\r\n\r\nOnce you have created a [Database] object, according to the steps in the [Official Documentation],\r\nyou get access to the methods documented below. \r\n\r\n## Methods \r\n\r\nAll query methods of the library are based off generic method [query].\r\n\r\nYou should normally use only the derived, result-specific methods for executing queries, all of which are named according\r\nto how many rows of data the query is expected to return, so for each query you should pick the right method:\r\n[none], [one], [oneOrNone], [many], [manyOrNone] = [any]. Do not confuse the method name for the number of rows\r\nto be affected by the query, which is completely irrelevant.\r\n\r\nBy relying on the result-specific methods you protect your code from an unexpected number of data rows,\r\nto be automatically rejected (treated as errors).  \r\n\r\nThere are also more specific methods that you will often need:\r\n\r\n* [result], [multi], [multiResult] - for verbose and/or multi-query results;\r\n* [map], [each] - for simpler/inline result pre-processing/re-mapping;\r\n* [func], [proc] - to simplify execution of SQL functions/procedures;\r\n* [task], [tx], [connect] - for shared connections + automatic transactions; \r\n* [stream] - to access rows from a query via a read stream.\r\n\r\n**IMPORTANT:**\r\n\r\nThe most important methods to understand from the beginning are [task] and [tx]. As documented for method [query],\r\nit acquires and releases the connection, which makes it a poor choice for executing multiple queries at once.\r\nFor this reason, [Chaining Queries] is an absolute must-read, to avoid writing the code that misuses connections.\r\n\r\nAt this point, it is best to follow the [Learn by Example] tutorial, for an easy start.\r\n\r\n## Query Formatting\r\n\r\nThis library comes with embedded query-formatting engine that offers high-performance value escaping,\r\nflexibility and extensibility. It is used by default with all query methods, unless you decide to opt out\r\nof it entirely via option `pgFormatting` within [Initialization Options].  \r\n\r\nAll formatting methods used internally are available from the [formatting] namespace, so they can also be used\r\ndirectly when needed. The main method there is [format], which is used by every query method to format the query. \r\n\r\nThe formatting syntax is decided from the type of `values` passed in:\r\n\r\n* [Index Variables] when `values` is an array or a single basic type;\r\n* [Named Parameters] when `values` is an object (other than `Array` or `null`).\r\n\r\n### Index Variables\r\n\r\nThe simplest (classic) formatting uses `$1, $2, ...` syntax to inject values into the query string,\r\nbased on their index (starting with 1) from the array of values: \r\n\r\n```js\r\ndb.any('SELECT * FROM product WHERE price BETWEEN $1 AND $2', [1, 10])\r\n```\r\n\r\nThe formatting engine also supports single-value parametrization for queries that use only a single `$1` variable: \r\n\r\n```js\r\ndb.any('SELECT * FROM users WHERE name = $1', 'John')\r\n```\r\n\r\nThis however works only for basic types, such as `number`, `string`, `boolean`, `Date`, `null`, `undefined`, because\r\ntypes like `Array` and `Object` change the way parameters are interpreted. That's why passing in index variables\r\nwithin an array is advised as safer, to avoid ambiguities.\r\n\r\n### Named Parameters\r\n\r\nWhen a query method is parameterized with `values` as an object, the formatting engine expects the query to use\r\nthe Named Parameter syntax `$*propName*`, with `*` being any of the following open-close pairs: `{}`, `()`, `<>`, `[]`, `//`.\r\n\r\n```js\r\ndb.any('SELECT * FROM users WHERE name = ${name} AND active = $/active/', {\r\n    name: 'John',\r\n    active: true\r\n});\r\n```\r\n\r\nValid variable names are limited to the syntax of an open-name JavaScript variable. \r\n\r\nKeep in mind that while property values `null` and `undefined` are both formatted as `null`,\r\nan error is thrown when the property does not exist.\r\n\r\n**`this` reference**\r\n\r\nProperty `this` refers to the formatting object itself, to be inserted as a JSON-formatted string.\r\n\r\n```js\r\ndb.none('INSERT INTO documents(id, doc) VALUES(${id}, ${this})', {\r\n    id: 123,\r\n    body: 'some text'    \r\n})\r\n//=> INSERT INTO documents(id, doc) VALUES(123, '{\"id\":123,\"body\":\"some text\"}')\r\n```    \r\n\r\n#### Nested Named Parameters\r\n\r\nStarting from v6.10.0, the library supports _Nested Named Parameters_:\r\n\r\n```js\r\nconst obj = {\r\n    one: {\r\n        two: {\r\n            three: 123\r\n        }\r\n    }\r\n};\r\ndb.any('SELECT ${one.two.three} FROM table', obj);\r\n```\r\n\r\nPlease note, however, that this supports does not extend to the [helpers] namespace.\r\n\r\n## Formatting Filters\r\n\r\nBy default, all values are formatted according to their JavaScript types. Formatting filters (or modifiers),\r\nchange that, so the value is formatted differently. \r\n\r\nFilters use the same syntax for [Index Variables] and [Named Parameters], following immediately the variable name:\r\n\r\n```js\r\ndb.any('SELECT $1:name FROM $2:name', ['price', 'products'])\r\n//=> SELECT \"price\" FROM \"products\"\r\n\r\ndb.any('SELECT ${column:name} FROM ${table:name}', {\r\n    column: 'price',\r\n    table: 'products'    \r\n});\r\n//=> SELECT \"price\" FROM \"products\"\r\n```\r\n\r\nThe following filters are supported:\r\n\r\n* `:name` / `~` - [SQL Names]\r\n* `:raw` / `^` - [Raw Text]\r\n* `:value` / `#` - [Open Values]\r\n* `:alias` - [Alias Filter]\r\n* `:json` - [JSON Filter]\r\n* `:csv` - [CSV Filter]\r\n\r\n### SQL Names\r\n\r\nWhen a variable ends with `:name`, or shorter syntax `~` (tilde), it represents an SQL name or identifier,\r\nto be escaped accordingly, and then wrapped in double quotes:\r\n\r\n```js\r\ndb.query('INSERT INTO $1~($2~) VALUES(...)', ['Table Name', 'Column Name']);\r\n//=> INSERT INTO \"Table Name\"(\"Column Name\") VALUES(...)\r\n```\r\n\r\nTypically, an SQL name variable is a text string, which must be at least 1 character long.\r\nHowever, `pg-promise` supports a variety of ways in which SQL names can be supplied:\r\n\r\n* A string that contains only `*` (asterisks) is automatically recognized as _all columns_:\r\n\r\n```js\r\ndb.query('SELECT $1:name FROM $2:name', ['*', 'table']);\r\n//=> SELECT * FROM \"table\"\r\n```\r\n\r\n* An array of strings to represent column names:\r\n\r\n```js\r\ndb.query('SELECT ${columns:name} FROM ${table:name}', {\r\n    columns: ['column1', 'column2'],\r\n    table: 'table'\r\n});\r\n//=> SELECT \"column1\",\"column2\" FROM \"table\"\r\n```\r\n\r\n* Any object that's not an array gets its properties enumerated for column names:\r\n\r\n```js\r\nconst obj = {\r\n    one: 1,\r\n    two: 2\r\n};\r\ndb.query('SELECT $1:name FROM $2:name', [obj, 'table']);\r\n//=> SELECT \"one\",\"two\" FROM \"table\"\r\n```\r\n\r\nIn addition, the syntax supports `this` to enumerate column names from the formatting object:\r\n \r\n```js\r\nconst obj = {\r\n    one: 1,\r\n    two: 2\r\n};\r\ndb.query('INSERT INTO table(${this:name}) VALUES(${one}, ${two})', obj);\r\n//=> INSERT INTO table(\"one\",\"two\") VALUES(1, 2)\r\n```\r\n\r\nRelying on this type of formatting for sql names and identifiers, along with regular variable formatting\r\nmakes your application impervious to [SQL injection].\r\n\r\nMethod [as.name] implements the formatting.\r\n\r\n#### Alias Filter\r\n\r\nAn alias is a lighter (simpler + faster) SQL name, which only supports a text string, and is used via the `:alias` filter:\r\n\r\n```js\r\ndb.any('SELECT $1:alias FROM $2:name', ['col', 'table']);\r\n//=> SELECT \"col\" FROM \"table\"\r\n```\r\n\r\nMethod [as.alias] implements the formatting.\r\n\r\n### Raw Text\r\n\r\nWhen a variable ends with `:raw`, or shorter syntax `^`, the value is to be injected as raw text, without escaping.\r\n\r\nSuch variables cannot be `null` or `undefined`, because of the ambiguous meaning in this case, and those values\r\nwill throw error `Values null/undefined cannot be used as raw text.`\r\n\r\n```js\r\nconst where = pgp.as.format('WHERE price BETWEEN $1 AND $2', [5, 10]); // pre-format WHERE condition\r\ndb.any('SELECT * FROM products $1:raw', where);\r\n//=> SELECT * FROM products WHERE price BETWEEN 5 AND 10\r\n```\r\n\r\nSpecial syntax `this:raw` / `this^` is supported, to inject the formatting object as raw JSON string.\r\n\r\n### Open Values\r\n\r\nWhen a variable ends with `:value`, or shorter syntax `#`, it is escaped as usual, except when its type is a string,\r\nthe trailing quotes are not added.\r\n\r\nOpen values are primarily to be able to compose complete `LIKE`/`ILIKE` dynamic statements in external SQL files,\r\nwithout having to generate them in the code.\r\n\r\ni.e. you can either generate a filter like this in your code:\r\n\r\n```js\r\nconst name = 'John';\r\nconst filter = '%' + name + '%';\r\n```\r\n\r\nand then pass it in as a regular string variable, or you can pass in only `name`, and have your query use the\r\nopen-value syntax to add the extra search logic:\r\n\r\n```sql\r\nSELECT * FROM table WHERE name LIKE '%$1:value%')\r\n```\r\n\r\nMethod [as.value] implements the formatting.\r\n\r\n### JSON Filter\r\n\r\nWhen a variable ends with `:json`, explicit JSON formatting is applied to the value.\r\n\r\nBy default, any object that's not `Date`, `Array`, `null` or Custom-Type (see [Custom Type Formatting]),\r\nis automatically formatted as JSON.\r\n\r\nMethod [as.json] implements the formatting.\r\n\r\n### CSV Filter\r\n\r\nWhen a variable ends with `:csv`, it is formatted as a list of Comma-Separated Values, with each\r\nvalue formatted according to its JavaScript type.\r\n \r\nTypically, you would use this for a value that's an array. However, when it is not an array, the single value\r\nis formatted as usual - like there is no filter specified. \r\n\r\n```js\r\nconst ids = [1, 2, 3];\r\ndb.any('SELECT * FROM table WHERE id IN ($1:csv)', [ids])\r\n//=> SELECT * FROM table WHERE id IN (1,2,3)\r\n```\r\n\r\nMethod [as.csv] implements the formatting.\r\n\r\n## Custom Type Formatting\r\n\r\nAny value/object that has function `toPostgres` is treated as a custom formatting type. The function is called to get\r\nthe actual value, passing it the value/object via `this` context, and as a single parameter (in case `toPostgres` is an ES6 arrow function):\r\n\r\n```js\r\nconst obj = {\r\n    toPostgres(self) {\r\n        // self = this = obj\r\n        \r\n        // return the actual value here\r\n    }\r\n}\r\n```\r\n\r\nThe value returned from `toPostgres` is escaped according to its JavaScript type, unless the object also contains\r\nproperty `_rawType` set to a truthy value, in which case the returned value is considered pre-formatted, and thus injected directly,\r\nas [Raw Text].\r\n\r\nExample below implements a class that auto-formats `ST_MakePoint` from coordinates:\r\n\r\n```js\r\nfunction STPoint(x, y) {\r\n    this._rawType = true; // no escaping, because we return pre-formatted SQL\r\n    this.toPostgres = () => pgp.as.format('ST_MakePoint($1, $2)', [x, y]);\r\n}\r\n```\r\n\r\nWith this class you can use `new STPoint(12, 34)` as a formatting value that will be injected correctly.  \r\n\r\nYou can also use _Custom Type Formatting_ to override any standard type:\r\n\r\n```js\r\nDate.prototype.toPostgres = a => a.getTime();\r\n```\r\n\r\nFunction `toPostgres` can return anything, including another object with its own `toPostgres`.\r\n\r\n## Query Files\r\n  \r\nUse of external SQL files (via [QueryFile]) offers many advantages:\r\n\r\n* Much cleaner JavaScript code, with all SQL kept in external files;\r\n* Much easier to write large and well-formatted SQL, with comments and whole revisions;\r\n* Changes in external SQL can be automatically re-loaded (option `debug`), without restarting the app;\r\n* Pre-formatting SQL upon loading (option `params`), making a two-step SQL formatting a breathe;\r\n* Parsing and minifying SQL (options `minify`/`compress`), for early error detection and compact queries.\r\n\r\nExample:\r\n\r\n```js\r\nconst path = require('path');\r\n\r\n// Helper for linking to external query files:\r\nfunction sql(file) {\r\n    const fullPath = path.join(__dirname, file);\r\n    return new pgp.QueryFile(fullPath, {minify: true});\r\n}\r\n\r\n// Create a QueryFile globally, once per file:\r\nconst sqlFindUser = sql('./sql/findUser.sql');\r\n\r\ndb.one(sqlFindUser, {id: 123})\r\n    .then(user => {\r\n        console.log(user);\r\n    })\r\n    .catch(error => {\r\n        if (error instanceof pgp.errors.QueryFileError) {\r\n            // => the error is related to our QueryFile\r\n        }\r\n    });\r\n```\r\n\r\nFile `findUser.sql`:\r\n\r\n```sql\r\n/*\r\n    multi-line comments are supported\r\n*/\r\nSELECT name, dob -- single-line comments are supported\r\nFROM Users\r\nWHERE id = ${id}\r\n```\r\n\r\nEvery query method of the library can accept type [QueryFile] as its `query` parameter.\r\nThe type never throws any error, leaving it for query methods to gracefully reject with [QueryFileError].\r\n\r\n## Tasks\r\n\r\nA [task] represents a shared connection for executing multiple queries:\r\n\r\n```js\r\ndb.task(t => {\r\n    // execute a chain of queries;\r\n})\r\n    .then(data => {\r\n        // success;\r\n    })\r\n    .catch(error => {\r\n        // failed;    \r\n    });\r\n```\r\n\r\nTasks provide a shared connection context for its callback function, to be released when finished.\r\nSee also [Chaining Queries] to understand the importance of using tasks.\r\n\r\n## Transactions\r\n\r\nTransaction method [tx] is like [task] that also executes `BEGIN` + `COMMIT`/`ROLLBACK` when needed:\r\n\r\n```js\r\ndb.tx(t => {\r\n    // creating a sequence of transaction queries:\r\n    const q1 = t.none('UPDATE users SET active = $1 WHERE id = $2', [true, 123]);\r\n    const q2 = t.one('INSERT INTO audit(entity, id) VALUES($1, $2) RETURNING id',\r\n        ['users', 123]);\r\n\r\n    // returning a promise that determines a successful transaction:\r\n    return t.batch([q1, q2]); // all of the queries are to be resolved;\r\n})\r\n    .then(data => {\r\n        console.log(data); // successful transaction output;\r\n    })\r\n    .catch(error => {\r\n        console.log(error);\r\n    });\r\n```\r\n\r\n### Nested Transactions\r\n\r\nNested transactions automatically share the connection between all levels.\r\nThis library sets no limitation as to the depth (nesting levels) of transactions supported.\r\n\r\nExample:\r\n\r\n```js\r\ndb.tx(t => {\r\n    const queries = [\r\n        t.none('DROP TABLE users;'),\r\n        t.none('CREATE TABLE users(id SERIAL NOT NULL, name TEXT NOT NULL)')\r\n    ];\r\n    for (let i = 1; i <= 100; i++) {\r\n        queries.push(t.none('INSERT INTO users(name) VALUES($1)', 'name-' + i));\r\n    }\r\n    queries.push(\r\n        t.tx(t1 => {\r\n            return t1.tx(t2 => {\r\n                return t2.one('SELECT count(*) FROM users');\r\n            });\r\n        }));\r\n    return t.batch(queries);\r\n})\r\n    .then(data => {\r\n        console.log(data); // printing transaction result;\r\n    })\r\n    .catch(error => {\r\n        console.log(error); // printing the error;\r\n    });\r\n```\r\n\r\n### Implementation details\r\n\r\nIt is important to know that PostgreSQL does not support full/atomic nested transactions, it only\r\nsupports [savepoints](http://www.postgresql.org/docs/9.4/static/sql-savepoint.html) inside\r\ntransactions. Nested transactions and save-points are two ways to deal with *partial rollbacks*.\r\nSave-points are more general and allow this library to offer you nested transactions as an\r\nabstraction.\r\n\r\nSave-points allow you to rollback to any previous state since the beginning of the (only) top-level\r\ntransaction. Nested transactions allow you to only rollback to the state at the beginning of\r\nthe current transaction. Proper support for nested transactions means that the result of a\r\nsuccessful sub-transaction or query is rolled back when its parent transaction is rolled back.\r\n\r\nFrom a practical point of view, it means that when using nested transactions, a rollback knows\r\nautomatically which state to restore but when using save-points you must specify which previous\r\nsave-point to use.\r\nThis library tracks the save-points for you so you can work as if nested transactions were\r\nsupported by Postgres.\r\n\r\nIt is important to note that when using either save-points or \"real\" nested transactions (which are\r\ntools for partial rollbacks), data is finally written only when the top level transaction is\r\ncommitted.\r\n\r\nAlso, Postgres uses `BEGIN` amd `COMMIT / ROLLBACK` for the top transaction and `SAVEPOINT pointName`\r\nand `ROLLBACK TO pointName` for inner save-points. This library automatically provides a transaction\r\non the top level, and save-points for all sub-transactions.\r\n\r\n### Limitations\r\n\r\nThis implementation of nested transactions has the following transactions\r\n- The `txMode` property of sub-transactions is ignored. The transaction mode is only applied for\r\n  `BEGIN` statements, so only for top-level transactions.\r\n- `SET TRANSACTION` statements are only effective if they are called before any query of the\r\n  real Postgres transaction. This means that once any nested transaction does a query, the\r\n  transaction mode is locked for the whole transaction tree.\r\n\r\nSee the implementation details above for more information.\r\n\r\n### Configurable Transactions\r\n\r\nIn order to be able to fine-tune database requests in a highly asynchronous environment,\r\nPostgreSQL supports *Transaction Snapshots*, plus 3 ways of configuring a transaction:\r\n\r\n* [SET TRANSACTION](http://www.postgresql.org/docs/9.4/static/sql-set-transaction.html), to configure the current transaction,\r\nwhich your can execute as the very first query in your transaction function;\r\n* `SET SESSION CHARACTERISTICS AS TRANSACTION` - setting default transaction properties for the entire session; \r\n* [BEGIN](http://www.postgresql.org/docs/9.4/static/sql-begin.html) + `Transaction Mode` - initiates a pre-configured transaction.\r\n\r\nThe first method is quite usable, but that means you have to start every transaction with\r\nan initial query to configure the transaction, which can be a bit awkward.\r\n\r\nThe second approach isn't very usable within a database framework as this one, which relies\r\non a connection pool, so you don't really know when a new connection is created.\r\n\r\nThe last method is not usable, because transactions in this library are automatic, executing `BEGIN`\r\nwithout your control, or so it was until [Transaction Mode] type was added (read further).\r\n\r\n---  \r\n\r\n[Transaction Mode] extends the `BEGIN` command in your transaction with a complete set of configuration parameters.\r\n\r\n```js\r\nconst TransactionMode = pgp.txMode.TransactionMode;\r\nconst isolationLevel = pgp.txMode.isolationLevel;\r\n \r\n// Create a reusable transaction mode (serializable + read-only + deferrable):\r\nconst tmSRD = new TransactionMode({\r\n    tiLevel: isolationLevel.serializable,\r\n    readOnly: true,\r\n    deferrable: true\r\n});\r\n\r\nfunction myTransaction() {\r\n    return this.query('SELECT * FROM table');\r\n}\r\n\r\nmyTransaction.txMode = tmSRD; // assign transaction mode;\r\n\r\ndb.tx(myTransaction)\r\n    .then(() => {\r\n        // success;\r\n    });\r\n```\r\n\r\nInstead of the default `BEGIN`, such transaction will initiate with the following command:\r\n```\r\nBEGIN ISOLATION LEVEL SERIALIZABLE READ ONLY DEFERRABLE\r\n```\r\n\r\nTransaction Mode is set via property `txMode` on the transaction function.\r\n\r\nThis is the most efficient and best-performing way of configuring transactions. In combination with\r\n*Transaction Snapshots* you can make the most out of transactions in terms of performance and concurrency.\r\n\r\n## ES6 Generators\r\n\r\nIf you prefer writing asynchronous code in a synchronous manner, you can implement your tasks and transactions as generators. \r\n\r\n```js\r\nfunction * getUser(t) {\r\n    const user = yield t.oneOrNone('SELECT * FROM users WHERE id = $1', 123);\r\n    return yield user || t.one('INSERT INTO users(name) VALUES($1) RETURNING *', 'John');\r\n}\r\n\r\ndb.task(getUser)\r\n    .then(user => {\r\n        // success;\r\n    })\r\n    .catch(error => {\r\n        // error;\r\n    });\r\n```\r\n\r\nThe library verifies whether the callback function is a generator, and executes it accordingly.\r\n\r\n## Library de-initialization\r\n\r\nWhen exiting your application, you can optionally call [pgp.end]:\r\n\r\n```js\r\npgp.end(); // shuts down all connection pools\r\n```\r\n\r\nThis will release all connection pools, to make sure the process can terminate without any delay.\r\nIf you do not call it, your process may be waiting for 30 seconds (default for [poolIdleTimeout](https://github.com/brianc/node-postgres/blob/master/lib/defaults.js#L46)),\r\nwaiting for all connections to expire in every pool.\r\n\r\nIf, however you normally exit your application by killing the NodeJS process, then you don't need to use it.\r\n\r\n# History\r\n\r\nFor the list of all changes see the [CHANGELOG](CHANGELOG.md).\r\n\r\n# License\r\n\r\nCopyright (c) 2017 Vitaly Tomilov\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\r\nto deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\nand/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\nDEALINGS IN THE SOFTWARE.\r\n\r\n<!-- Internal Menu Links -->\r\n\r\n[Usage]:#usage\r\n[Index Variables]:#index-variables  \r\n[Named Parameters]:#named-parameters\r\n[SQL Names]:#sql-names\r\n[Raw Text]:#raw-text\r\n[Open Values]:#open-values\r\n[Alias Filter]:#alias-filter\r\n[JSON Filter]:#json-filter\r\n[CSV Filter]:#csv-vilter\r\n[Custom Type Formatting]:#custom-type-formatting\r\n\r\n<!-- Method Links -->\r\n\r\n[query]:http://vitaly-t.github.io/pg-promise/Database.html#query\r\n[none]:http://vitaly-t.github.io/pg-promise/Database.html#none\r\n[one]:http://vitaly-t.github.io/pg-promise/Database.html#one\r\n[oneOrNone]:http://vitaly-t.github.io/pg-promise/Database.html#oneOrNone\r\n[many]:http://vitaly-t.github.io/pg-promise/Database.html#many\r\n[manyOrNone]:http://vitaly-t.github.io/pg-promise/Database.html#manyOrNone\r\n[any]:http://vitaly-t.github.io/pg-promise/Database.html#any\r\n[result]:http://vitaly-t.github.io/pg-promise/Database.html#result\r\n[multi]:http://vitaly-t.github.io/pg-promise/Database.html#multi\r\n[multiResult]:http://vitaly-t.github.io/pg-promise/Database.html#multiResult\r\n[map]:http://vitaly-t.github.io/pg-promise/Database.html#map\r\n[each]:http://vitaly-t.github.io/pg-promise/Database.html#each\r\n[func]:http://vitaly-t.github.io/pg-promise/Database.html#func\r\n[proc]:http://vitaly-t.github.io/pg-promise/Database.html#proc\r\n[stream]:http://vitaly-t.github.io/pg-promise/Database.html#stream\r\n[connect]:http://vitaly-t.github.io/pg-promise/Database.html#connect\r\n[task]:http://vitaly-t.github.io/pg-promise/Database.html#task\r\n[tx]:http://vitaly-t.github.io/pg-promise/Database.html#tx\r\n[batch]:http://vitaly-t.github.io/pg-promise/Task.html#batch\r\n[sequence]:http://vitaly-t.github.io/pg-promise/Task.html#sequence\r\n[page]:http://vitaly-t.github.io/pg-promise/Task.html#page\r\n\r\n<!-- API Links -->\r\n\r\n[Official Documentation]:http://vitaly-t.github.io/pg-promise/index.html\r\n[Initialization Options]:http://vitaly-t.github.io/pg-promise/module-pg-promise.html\r\n[helpers]:http://vitaly-t.github.io/pg-promise/helpers.html\r\n[QueryFile]:http://vitaly-t.github.io/pg-promise/QueryFile.html\r\n[QueryFileError]:http://vitaly-t.github.io/pg-promise/QueryFileError.html\r\n[Database]:http://vitaly-t.github.io/pg-promise/Database.html\r\n[pgp.end]:http://vitaly-t.github.io/pg-promise/module-pg-promise.html#~end\r\n[formatting]:http://vitaly-t.github.io/pg-promise/formatting.html\r\n[as.format]:http://vitaly-t.github.io/pg-promise/formatting.html#.format\r\n[format]:http://vitaly-t.github.io/pg-promise/formatting.html#.format\r\n[as.value]:http://vitaly-t.github.io/pg-promise/formatting.html#.value\r\n[as.csv]:http://vitaly-t.github.io/pg-promise/formatting.html#.csv\r\n[as.json]:http://vitaly-t.github.io/pg-promise/formatting.html#.json\r\n[as.name]:http://vitaly-t.github.io/pg-promise/formatting.html#.name\r\n[as.alias]:http://vitaly-t.github.io/pg-promise/formatting.html#.alias\r\n[Transaction Mode]:http://vitaly-t.github.io/pg-promise/txMode.TransactionMode.html\r\n\r\n<!-- WiKi Links -->\r\n\r\n[Learn by Example]:https://github.com/vitaly-t/pg-promise/wiki/Learn-by-Example\r\n[Chaining Queries]:https://github.com/vitaly-t/pg-promise/wiki/Chaining-Queries\r\n\r\n<!-- External Links -->\r\n\r\n[node-postgres]:https://github.com/brianc/node-postgres\r\n[Promises/A+]:https://promisesaplus.com/\r\n[Bluebird]:https://github.com/petkaantonov/bluebird\r\n[SQL injection]:https://en.wikipedia.org/wiki/SQL_injection\r\n",
  "readmeFilename": "README.md",
  "_id": "pg-promise@7.0.3",
  "dist": {
    "shasum": "0dcc7c05d2deb5cb9e37b1eecdc67213a0e9ed39"
  },
  "_from": "pg-promise@7.0.3",
  "_resolved": "https://registry.npmjs.org/pg-promise/-/pg-promise-7.0.3.tgz"
}
